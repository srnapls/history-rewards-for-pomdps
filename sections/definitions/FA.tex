\subsection{Deterministic Finite Automata}
Simple deterministic processes can be easily modeled with the help of a finite-state machine. Specifically, if we are interested in wether an input string should be accepted, we can use Deterministic Finite Automata.

\begin{definition}[DFA]
A deterministic finite automaton is a tuple $D=(Q,q_0,\Sigma,\delta,F)$ where 
\begin{itemize}
\item $Q$, the finite set of states;
\item $q_0$, the initial state;
\item $\Sigma$ the input alphabet;
\item $\delta: Q\times\Sigma\to Q$, the deterministic transition function;
\item $F\subseteq Q$, the set of final states.
\end{itemize}
\end{definition}


\subsection*{Example}
\begin{figure}[H]
	\centering
		\begin{tikzpicture}[node distance=3cm,on grid,auto,shorten >=1pt]
			\node[initial,state,accepting] (0) 		{$q_0$};
			\node[state] (1) [above right=of 0]		{$q_1$};
			\node[state] (2) [below right=of 1]		{$q_2$};
			\path[->] 	(0) edge 	node [below] {$a$}	(1)
							edge [bend right]   node [below] {$b$}	(2)
						(1) edge 	node [left] {$a$}	(2)
							edge [bend right]    node [above] {$b$}	(0)
						(2) edge 	node [above] {$a$}	(0)
							edge [bend right]    node [right] {$b$}	(1);
	\end{tikzpicture}
\caption{DFA over $\Sigma=\{a,b\}$ which accepts words if the number of $a$'s and $b$'s are equal modulo $3$.}
\end{figure}

Since we are interested in wether an input string should be accepted or not, we are specifically interested in how a DFA handles certain words and where a DFA will finish after reading a word. Since DFAs are deterministic, this can be easily described. 

\begin{definition}
We define $\delta^*:Q\times\Sigma^*\to Q$ where $\delta^*(q,w)$ denotes the state we end up after reading word $w$ starting from state $q$ as follows
\begin{equation*}
\delta^*(q,w)=\begin{cases}
	q &\text{if } w=\epsilon \\
	\delta^*(\delta(q,a_1),a_2\dots a_n) & \text{if } w=a_1a_2\dots a_n
	\end{cases}
\end{equation*}
\label{d:delta_star}
\end{definition}

\begin{definition}
We say the language accepted by a DFA $D=(Q,q_0,\Sigma,\delta,F)$ consists of all the words that start in the begin state and finish in any final state. Thus $L(D)=\{w\in\Sigma^*\mid \delta^*(q_0,w)\in F\}$.
\label{d:accepted_language}
\end{definition}


\subsection{Moore machine}
A Moore machine is a finite state machine, similar to the previously mentioned DFA. As we have seen, DFAs are used to show the acceptability of words. This is done by allowing some states to be final, i.e. encoding the acceptability in the states. However, instead of accepting words, Moore machine simply process words and present us with an output while or after reading a sequence. Thus instead of encoding acceptability in the states, we encode an output. 

Based on the definition as presented in \cite{p:moore}.
\begin{definition}
	A Moore machine is a tuple $(Q,q_0,\Sigma,O,\delta,\sigma)$ where
	\begin{itemize}
		\item $Q$, the finite set of states;
		\item $q_0\in Q$, the initial state;
		\item $\Sigma$, the finite set of input characters - the input alphabet;
		\item $O$, the finite set of output characters - the output alphabet;
		\item $\delta: Q\times \Sigma\to Q$, the input transition function, and;
		\item $\sigma : Q\to O$, the output transition function.
	\end{itemize}
\end{definition}

\subsection*{Example}
As previously mentioned, we can obtain an output while reading a sequence or after reading a sequence. First let us look at obtaining an output while reading. This can be interpreted as transforming some sequence into another sequence. As seen in the definition the output is encoded in the state, so by passing through a state, we obtain a singular output. After the entire input sequence is passed through the machine, we have obtain a new sequence based on the outputs encoded in the states.

In \figureref{f:moore_a} we have for $\Sigma=O=\{0,1\}$ a machine that inverts a given sequence. The inverted sequence will however also be preceded by a $1$ per construction. For example, when we pass through the sequence $1110$, we obtain $10001$. 

Another usage of Moore machines is to only obtain the output after we are done with reading the sequence. For example, in \figureref{f:moore_b} we have $\Sigma=\{a,b\}$ and $O=\{\emptyset,\{a\},\{b\},\{a,b\}\}$. The machine outputs the set of used letters in the sequence after being done with reading the sequence. So after reading the sequence $aaa$, we will then obtain $\{a\}$.

\begin{figure}[H]
\begin{subfigure}[H]{0.4\textwidth}
	\centering
		\begin{tikzpicture}[node distance=3cm,on grid,auto,shorten >=1pt]
			\node[initial,state] (0) 				{$q_0$/1};
			\node[state] (1) [right=of 0]		{$q_1$/0};
			\path[->] 	(0) edge [loop above]	node [above] {0}	(0)
							edge [bend left]   node [above] {1}	(1)
						(1) edge [loop above]	node [above] {1}	(1)
							edge [bend left]    node [above] {0}	(0);
	\end{tikzpicture}
	\caption{Inverting sequence}
	\label{f:moore_a}
\end{subfigure}
\begin{subfigure}[H]{0.4\textwidth}
	\centering
		\begin{tikzpicture}[node distance=3cm,on grid,auto,shorten >=1pt]
			\node[initial,state] (0) 		{$q_0/\emptyset$};
			\node[state] (1) [above right=of 0]		{$q_1/\{a\}$};
			\node[state] (2) [below right=of 0]		{$q_2/\{b\}$};
			\node[state] (3) [below right=of 1]      {$q_3/\{a,b\}$};
			\path[->] 	(0) edge 	node [below] {$a$}	(1)
							edge    node [below] {$b$}	(2)
						(1) edge [loop above] 	node [above] {$a$}	(1)
							edge    node [above] {$b$}	(3)
						(2) edge [loop above]	node [above] {$b$}	(2)
							edge    node [right] {$a$}	(3)
						(3) edge [loop above] node [above] {$a,b$}  ();
	\end{tikzpicture}
	\caption{Returns set of used letters}
	\label{f:moore_b}
\end{subfigure}
\end{figure}